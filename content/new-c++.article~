c++ new 动态内存管理
2013-10-02
Tags: c++

hominlinx

* 设计目标

C++程序存储空间分为静态/全局存储区、栈区、堆区。其中堆区最麻烦，要自己去申请和释放。这就要求对动态管理有一定了解。要知道如何使用C++ 特性实现高效的内存管理，以减少错误的发生。

1. new

C++的new有三种形态：new operator / operator new / placement new

(1)new operator（new expression）:

我们平时使用的new，这个不能重载，它实际上执行了三个动作：（1）获得一块内存空间（2）调用构造函数（3）返回正确的指针。注意：如果我们用new创建一个简单的内置变量，则第二步可以省略。其中第一步内存分配实际上调用operator new 来完成的。这个形态的new像+ -等操作符一样，因此 第一步也是可以重载的。默认情况下，首先调用分配内存的代码，尝试得到一段堆上的空间，如果成功就返回，如果失败则转去调用一个new_hander，然后继续重复前面的过程，当然不过不满意我们可以重载operator new ，来设置我们希望的行为。例如：

    class A
    {
    public:
        void * operator new(size_t size)
              {
                   printf("operator new call");
                   return ::operator new(size);
              }
    };
    A *a = new A();

这里通过 ::operator new调用了原有的全局的 new，实现了在分配内存之前输出一句话

(2)placement new（置换new）:

是用来实现定位构造的，包含头文件<new>后即可使用。这种形式主要适用于：a、对时间要求非常高的应用程序中，因为这些程序分配的时间是确定的。b、长时间运行而不被打断的程序。c、执行一个垃圾收集器。

    char buffer[100];
    char* p = new(buffer) char[20];
    又如：
    `c++`
    char *p = new(__FILE__,__LINE__) char[10];
    void * operator new (size_t size ,char * file , int line )
    {
         printf( "size:d ,new line at d\n",size ,line );
         return :: operator new( size);
    }
    #define new new(__FILE__ ,__LINE__ )

2. 避免内存泄露

一个复杂的C++程序中最容易出现，也是最头疼的一个问题就是内存泄露。虽然没有提供自动垃圾回收机制，C++还是提供了足够强大和灵活的机制，是开发人员可以有效的避免内存泄露。比如可以讲分配和释放的过程封装到一个类里，即在构造时分配内存，在析构时释放内存，从而保证没有内存泄露。实际上，早已出现了很多C++库，提供了称之为“智能指针”的模板类。

注意：如果一个类没有实现拷贝构造函数，编译器会构造一个默认的拷贝构造函数，执行位拷贝（bit cope）操作，即将对象a的内容逐个字节的拷贝到对象b中，因此，a中的指针和cope的b中指针是指向同一个地址，这样当a，b都被销毁时，m_buf指向的内存被销毁两次，造成错误，解决方式：禁止拷贝构造。另一种就是通过引用计数的方法，既避免了对同一块内存的多次删除，又允许实现拷贝构造。

3. 智能指针

智能指针就是存储指向动态内存、对象的指针的类。其使用和工作机制与C++内置的指针非常类似，而最大的不同时会再适当的时候自动删除指向的内存和对象。这些智能指针会考虑很多因素，如所有权、线程安全、以及异常安全问题等。智能指针主要有std::auto_ptr,boost的智能指针。

